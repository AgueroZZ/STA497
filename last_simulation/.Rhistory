RW2BINS = 60
POLYNOMIAL_DEGREE = 1
PARALLEL_EXECUTION = T
u <- runif(N)
x <- seq(from = -30, to = 30, length.out = N)
eta <- 2/(1+exp(-0.2*x)) + rnorm(length(x),sd = exp(-.5*12))
truefunc <- function(x) 2/(1+exp(-0.2*x))
tibble(x = c(-30,30)) %>%
ggplot(aes(x = x)) +
theme_light() +
stat_function(fun = truefunc)
failtimes <- c()
for (i in 1:N) {
hazz <- haz * exp(eta[i])
cumhaz <- cumsum(hazz*0.001)
Surv <- exp(-cumhaz)
failtimes[i] <- tdom[colSums(outer(Surv, u[i], `>`))]
}
data <- data_frame(x=x,times = failtimes, entry = rep(0,length(length(u))),censoring = ifelse(failtimes>=2000,yes = 0, no=1))
for (i in 1:length(data$censoring)) {
if(data$censoring[i]==1) data$censoring[i] <- rbinom(n=1,size=1,p=0.8)
}
data <- rename(data,exposure = x)
data <- data %>% as_tibble() %>%
mutate(exposure_binned = bin_covariate(exposure,bins = RW2BINS,type = "quantile"))
data <- arrange_data(data)
data$ID <- 1:length(u)
Alist <- list()
Alist$exposure <- create_alist_element(data$exposure_binned)
model_data <- list(
A = Alist,
M = Alist %>% map("A") %>% map(ncol) %>% reduce(sum) - 1,
n = length(unique(data$ID)),
X = sparse.model.matrix(eta ~ -1 + poly(exposure,degree = POLYNOMIAL_DEGREE,raw = TRUE),data = data)
)
model_data$theta_logprior <- function(theta,prior_alpha = .5,prior_u = log(10)) {
lambda <- -log(prior_alpha)/prior_u
log(lambda/2) - lambda * exp(-theta/2) - theta/2
}
model_data$beta_logprec <- log(.5)
model_data$diffmat <- create_diff_matrix(model_data$n)
model_data$lambdainv <- create_full_dtcp_matrix(model_data$n)
model_data$Xd <- model_data$diffmat %*% model_data$X
model_data$p <- ncol(model_data$X)
model_data$Nd <- model_data$n - 1
model_data$Ne <- model_data$n
model_data$Wd <- model_data$M + model_data$p + model_data$Nd
model_data$Wdf <- model_data$M + model_data$p + model_data$Ne
model_data$times <- data$times
model_data$censoring <- data$censoring
model_data$entry <- data$entry
model_data$ID <- data$ID
model_data$diffmat <- create_diff_matrix(model_data$n)
model_data$lambdainv <- create_full_dtcp_matrix(model_data$n)
model_data$A$exposure$Ad <- model_data$diffmat %*% model_data$A$exposure$A
model_data$Xd <- model_data$diffmat %*% model_data$X
thetagrid <- as.list(seq(4,12,by = 0.1)) # This is the log(precision)
# Random effect model specification data
model_data$modelspec <- model_data$A %>%
purrr::map("model") %>%
purrr::map2(.,names(.),~tibble(covariate = .y,model = .x)) %>%
purrr::reduce(bind_rows)
model_data$vectorofcolumnstoremove <- round(RW2BINS/2)
cat("Finished creating model data!\n")
control1 <- list(
prec = 1e-08,
stop.trust.radius = 1e-10,
report.freq = 10,
report.level = 4,
start.trust.radius = 100,
contract.threshold = .25,
contract.factor = .5,
expand.factor = 3,
trust.iter = 2000,
maxit = 3000,
preconditioner = 0
)
formula <- inla.surv(times,censoring) ~ -1+exposure  + f(exposure_binned,model = 'rw2',constr = T)
Inlaresult <- inla(formula = formula, control.compute = list(dic=TRUE),control.inla = list(strategy = 'gaussian',int.strategy = 'grid', correct = FALSE),data = data, family = "coxph",
control.hazard = list(model="rw2",n.intervals = 20),
num.threads = 4)
fhat <- Inlaresult$summary.random$exposure_binned$mean
f.ub <- Inlaresult$summary.random$exposure_binned$`0.975quant`
f.lb <- Inlaresult$summary.random$exposure_binned$`0.025quant`
plotINLA <- data.frame(exposure = Inlaresult$summary.random$exposure_binned$ID)
fit_poly2 <- function(x){
xx <- poly(x,degree = POLYNOMIAL_DEGREE,raw = T)
as.numeric(xx %*% cbind(Inlaresult$summary.fixed[,1]))
}
mypoly = fit_poly2(plotINLA$exposure) - fit_poly2(plotINLA$exposure[vv])
meanhere <- fhat-fhat[vv] + mypoly
inlaplot <- ggplot(plotINLA, aes(x = exposure)) +
geom_line(aes(y = meanhere)) +
geom_line(aes(y = truefunc(exposure) - truefunc(exposure[vv])),colour = 'blue',linetype = 'solid') +
theme_bw(base_size = 20)
inlaplot
N
N = 2000
RW2BINS = 60
POLYNOMIAL_DEGREE = 1
PARALLEL_EXECUTION = T
u <- runif(N)
x <- seq(from = -30, to = 30, length.out = N)
eta <- 2/(1+exp(-0.2*x)) + rnorm(length(x),sd = exp(-.5*12))
truefunc <- function(x) 2/(1+exp(-0.2*x))
tibble(x = c(-30,30)) %>%
ggplot(aes(x = x)) +
theme_light() +
stat_function(fun = truefunc)
failtimes <- c()
for (i in 1:N) {
hazz <- haz * exp(eta[i])
cumhaz <- cumsum(hazz*0.001)
Surv <- exp(-cumhaz)
failtimes[i] <- tdom[colSums(outer(Surv, u[i], `>`))]
}
data <- data_frame(x=x,times = failtimes, entry = rep(0,length(length(u))),censoring = ifelse(failtimes>=2000,yes = 0, no=1))
for (i in 1:length(data$censoring)) {
if(data$censoring[i]==1) data$censoring[i] <- rbinom(n=1,size=1,p=0.8)
}
data <- rename(data,exposure = x)
data <- data %>% as_tibble() %>%
mutate(exposure_binned = bin_covariate(exposure,bins = RW2BINS,type = "quantile"))
data <- arrange_data(data)
data$ID <- 1:length(u)
Alist <- list()
Alist$exposure <- create_alist_element(data$exposure_binned)
model_data <- list(
A = Alist,
M = Alist %>% map("A") %>% map(ncol) %>% reduce(sum) - 1,
n = length(unique(data$ID)),
X = sparse.model.matrix(eta ~ -1 + poly(exposure,degree = POLYNOMIAL_DEGREE,raw = TRUE),data = data)
)
model_data$theta_logprior <- function(theta,prior_alpha = .5,prior_u = log(10)) {
lambda <- -log(prior_alpha)/prior_u
log(lambda/2) - lambda * exp(-theta/2) - theta/2
}
model_data$beta_logprec <- log(.5)
model_data$diffmat <- create_diff_matrix(model_data$n)
model_data$lambdainv <- create_full_dtcp_matrix(model_data$n)
model_data$Xd <- model_data$diffmat %*% model_data$X
model_data$p <- ncol(model_data$X)
model_data$Nd <- model_data$n - 1
model_data$Ne <- model_data$n
model_data$Wd <- model_data$M + model_data$p + model_data$Nd
model_data$Wdf <- model_data$M + model_data$p + model_data$Ne
model_data$times <- data$times
model_data$censoring <- data$censoring
model_data$entry <- data$entry
model_data$ID <- data$ID
model_data$diffmat <- create_diff_matrix(model_data$n)
model_data$lambdainv <- create_full_dtcp_matrix(model_data$n)
model_data$A$exposure$Ad <- model_data$diffmat %*% model_data$A$exposure$A
model_data$Xd <- model_data$diffmat %*% model_data$X
thetagrid <- as.list(seq(4,12,by = 0.1)) # This is the log(precision)
formula <- inla.surv(times,censoring) ~ -1+exposure  + f(exposure_binned,model = 'rw2',constr = T)
Inlaresult <- inla(formula = formula, control.compute = list(dic=TRUE),control.inla = list(strategy = 'gaussian',int.strategy = 'grid', correct = FALSE),data = data, family = "coxph",
control.hazard = list(model="rw2",n.intervals = 20),
num.threads = 4)
fhat <- Inlaresult$summary.random$exposure_binned$mean
f.ub <- Inlaresult$summary.random$exposure_binned$`0.975quant`
f.lb <- Inlaresult$summary.random$exposure_binned$`0.025quant`
plotINLA <- data.frame(exposure = Inlaresult$summary.random$exposure_binned$ID)
fit_poly2 <- function(x){
xx <- poly(x,degree = POLYNOMIAL_DEGREE,raw = T)
as.numeric(xx %*% cbind(Inlaresult$summary.fixed[,1]))
}
mypoly = fit_poly2(plotINLA$exposure) - fit_poly2(plotINLA$exposure[vv])
meanhere <- fhat-fhat[vv] + mypoly
inlaplot <- ggplot(plotINLA, aes(x = exposure)) +
geom_line(aes(y = meanhere)) +
geom_line(aes(y = truefunc(exposure) - truefunc(exposure[vv])),colour = 'blue',linetype = 'solid') +
theme_bw(base_size = 20)
inlaplot
# generate 800 random samples:
N = 2000
RW2BINS = 60
POLYNOMIAL_DEGREE = 1
PARALLEL_EXECUTION = T
u <- runif(N)
x <- seq(from = -30, to = 30, length.out = N)
eta <- 2/(1+exp(-0.2*x)) + rnorm(length(x),sd = exp(-.5*12))
truefunc <- function(x) 2/(1+exp(-0.2*x))
tibble(x = c(-30,30)) %>%
ggplot(aes(x = x)) +
theme_light() +
stat_function(fun = truefunc)
failtimes <- c()
for (i in 1:N) {
hazz <- haz * exp(eta[i])
cumhaz <- cumsum(hazz*0.001)
Surv <- exp(-cumhaz)
failtimes[i] <- tdom[colSums(outer(Surv, u[i], `>`))]
}
data <- data_frame(x=x,times = failtimes, entry = rep(0,length(length(u))),censoring = ifelse(failtimes>=2000,yes = 0, no=1))
for (i in 1:length(data$censoring)) {
if(data$censoring[i]==1) data$censoring[i] <- rbinom(n=1,size=1,p=0.9)
}
data <- rename(data,exposure = x)
data <- data %>% as_tibble() %>%
mutate(exposure_binned = bin_covariate(exposure,bins = RW2BINS,type = "quantile"))
data <- arrange_data(data)
data$ID <- 1:length(u)
Alist <- list()
Alist$exposure <- create_alist_element(data$exposure_binned)
model_data <- list(
A = Alist,
M = Alist %>% map("A") %>% map(ncol) %>% reduce(sum) - 1,
n = length(unique(data$ID)),
X = sparse.model.matrix(eta ~ -1 + poly(exposure,degree = POLYNOMIAL_DEGREE,raw = TRUE),data = data)
)
model_data$theta_logprior <- function(theta,prior_alpha = .5,prior_u = log(10)) {
lambda <- -log(prior_alpha)/prior_u
log(lambda/2) - lambda * exp(-theta/2) - theta/2
}
model_data$beta_logprec <- log(.5)
model_data$diffmat <- create_diff_matrix(model_data$n)
model_data$lambdainv <- create_full_dtcp_matrix(model_data$n)
model_data$Xd <- model_data$diffmat %*% model_data$X
model_data$p <- ncol(model_data$X)
model_data$Nd <- model_data$n - 1
model_data$Ne <- model_data$n
model_data$Wd <- model_data$M + model_data$p + model_data$Nd
model_data$Wdf <- model_data$M + model_data$p + model_data$Ne
model_data$times <- data$times
model_data$censoring <- data$censoring
model_data$entry <- data$entry
model_data$ID <- data$ID
model_data$diffmat <- create_diff_matrix(model_data$n)
model_data$lambdainv <- create_full_dtcp_matrix(model_data$n)
model_data$A$exposure$Ad <- model_data$diffmat %*% model_data$A$exposure$A
model_data$Xd <- model_data$diffmat %*% model_data$X
thetagrid <- as.list(seq(4,12,by = 0.1)) # This is the log(precision)
# Random effect model specification data
model_data$modelspec <- model_data$A %>%
purrr::map("model") %>%
purrr::map2(.,names(.),~tibble(covariate = .y,model = .x)) %>%
purrr::reduce(bind_rows)
model_data$vectorofcolumnstoremove <- round(RW2BINS/2)
cat("Finished creating model data!\n")
formula <- inla.surv(times,censoring) ~ -1+exposure  + f(exposure_binned,model = 'rw2',constr = T)
Inlaresult <- inla(formula = formula, control.compute = list(dic=TRUE),control.inla = list(strategy = 'gaussian',int.strategy = 'grid', correct = FALSE),data = data, family = "coxph",
control.hazard = list(model="rw2",n.intervals = 20),
num.threads = 4)
fhat <- Inlaresult$summary.random$exposure_binned$mean
f.ub <- Inlaresult$summary.random$exposure_binned$`0.975quant`
f.lb <- Inlaresult$summary.random$exposure_binned$`0.025quant`
plotINLA <- data.frame(exposure = Inlaresult$summary.random$exposure_binned$ID)
fit_poly2 <- function(x){
xx <- poly(x,degree = POLYNOMIAL_DEGREE,raw = T)
as.numeric(xx %*% cbind(Inlaresult$summary.fixed[,1]))
}
mypoly = fit_poly2(plotINLA$exposure) - fit_poly2(plotINLA$exposure[vv])
meanhere <- fhat-fhat[vv] + mypoly
inlaplot <- ggplot(plotINLA, aes(x = exposure)) +
geom_line(aes(y = meanhere)) +
geom_line(aes(y = truefunc(exposure) - truefunc(exposure[vv])),colour = 'blue',linetype = 'solid') +
theme_bw(base_size = 20)
inlaplot
N = 3000
RW2BINS = 60
POLYNOMIAL_DEGREE = 1
PARALLEL_EXECUTION = T
u <- runif(N)
x <- seq(from = -30, to = 30, length.out = N)
eta <- 2/(1+exp(-0.2*x)) + rnorm(length(x),sd = exp(-.5*12))
truefunc <- function(x) 2/(1+exp(-0.2*x))
tibble(x = c(-30,30)) %>%
ggplot(aes(x = x)) +
theme_light() +
stat_function(fun = truefunc)
failtimes <- c()
for (i in 1:N) {
hazz <- haz * exp(eta[i])
cumhaz <- cumsum(hazz*0.001)
Surv <- exp(-cumhaz)
failtimes[i] <- tdom[colSums(outer(Surv, u[i], `>`))]
}
data <- data_frame(x=x,times = failtimes, entry = rep(0,length(length(u))),censoring = ifelse(failtimes>=2000,yes = 0, no=1))
for (i in 1:length(data$censoring)) {
if(data$censoring[i]==1) data$censoring[i] <- rbinom(n=1,size=1,p=0.9)
}
data <- rename(data,exposure = x)
data <- data %>% as_tibble() %>%
mutate(exposure_binned = bin_covariate(exposure,bins = RW2BINS,type = "quantile"))
data <- arrange_data(data)
data$ID <- 1:length(u)
Alist <- list()
Alist$exposure <- create_alist_element(data$exposure_binned)
model_data <- list(
A = Alist,
M = Alist %>% map("A") %>% map(ncol) %>% reduce(sum) - 1,
n = length(unique(data$ID)),
X = sparse.model.matrix(eta ~ -1 + poly(exposure,degree = POLYNOMIAL_DEGREE,raw = TRUE),data = data)
)
model_data$theta_logprior <- function(theta,prior_alpha = .5,prior_u = log(10)) {
lambda <- -log(prior_alpha)/prior_u
log(lambda/2) - lambda * exp(-theta/2) - theta/2
}
model_data$beta_logprec <- log(.5)
model_data$diffmat <- create_diff_matrix(model_data$n)
model_data$lambdainv <- create_full_dtcp_matrix(model_data$n)
model_data$Xd <- model_data$diffmat %*% model_data$X
model_data$p <- ncol(model_data$X)
model_data$Nd <- model_data$n - 1
model_data$Ne <- model_data$n
model_data$Wd <- model_data$M + model_data$p + model_data$Nd
model_data$Wdf <- model_data$M + model_data$p + model_data$Ne
model_data$times <- data$times
model_data$censoring <- data$censoring
model_data$entry <- data$entry
model_data$ID <- data$ID
model_data$diffmat <- create_diff_matrix(model_data$n)
model_data$lambdainv <- create_full_dtcp_matrix(model_data$n)
model_data$A$exposure$Ad <- model_data$diffmat %*% model_data$A$exposure$A
model_data$Xd <- model_data$diffmat %*% model_data$X
thetagrid <- as.list(seq(4,12,by = 0.1)) # This is the log(precision)
# Random effect model specification data
model_data$modelspec <- model_data$A %>%
purrr::map("model") %>%
purrr::map2(.,names(.),~tibble(covariate = .y,model = .x)) %>%
purrr::reduce(bind_rows)
model_data$vectorofcolumnstoremove <- round(RW2BINS/2)
cat("Finished creating model data!\n")
#Comparison with INLA:
formula <- inla.surv(times,censoring) ~ -1+exposure  + f(exposure_binned,model = 'rw2',constr = T)
Inlaresult <- inla(formula = formula, control.compute = list(dic=TRUE),control.inla = list(strategy = 'gaussian',int.strategy = 'grid', correct = FALSE),data = data, family = "coxph",
control.hazard = list(model="rw2",n.intervals = 20),
num.threads = 4)
fhat <- Inlaresult$summary.random$exposure_binned$mean
f.ub <- Inlaresult$summary.random$exposure_binned$`0.975quant`
f.lb <- Inlaresult$summary.random$exposure_binned$`0.025quant`
plotINLA <- data.frame(exposure = Inlaresult$summary.random$exposure_binned$ID)
fit_poly2 <- function(x){
xx <- poly(x,degree = POLYNOMIAL_DEGREE,raw = T)
as.numeric(xx %*% cbind(Inlaresult$summary.fixed[,1]))
}
mypoly = fit_poly2(plotINLA$exposure) - fit_poly2(plotINLA$exposure[vv])
meanhere <- fhat-fhat[vv] + mypoly
inlaplot <- ggplot(plotINLA, aes(x = exposure)) +
geom_line(aes(y = meanhere)) +
geom_line(aes(y = truefunc(exposure) - truefunc(exposure[vv])),colour = 'blue',linetype = 'solid') +
theme_bw(base_size = 20)
inlaplot
# generate 600 random samples:
N = 600
RW2BINS = 60
POLYNOMIAL_DEGREE = 1
PARALLEL_EXECUTION = T
u <- runif(N)
x <- seq(from = -30, to = 30, length.out = N)
eta <- 2/(1+exp(-0.2*x)) + rnorm(length(x),sd = exp(-.5*12))
truefunc <- function(x) 2/(1+exp(-0.2*x))
tibble(x = c(-30,30)) %>%
ggplot(aes(x = x)) +
theme_light() +
stat_function(fun = truefunc)
failtimes <- c()
for (i in 1:N) {
hazz <- haz * exp(eta[i])
cumhaz <- cumsum(hazz*0.001)
Surv <- exp(-cumhaz)
failtimes[i] <- tdom[colSums(outer(Surv, u[i], `>`))]
}
data <- data_frame(x=x,times = failtimes, entry = rep(0,length(length(u))),censoring = ifelse(failtimes>=2000,yes = 0, no=1))
for (i in 1:length(data$censoring)) {
if(data$censoring[i]==1) data$censoring[i] <- rbinom(n=1,size=1,p=0.9)
}
data <- rename(data,exposure = x)
data <- data %>% as_tibble() %>%
mutate(exposure_binned = bin_covariate(exposure,bins = RW2BINS,type = "quantile"))
data <- arrange_data(data)
data$ID <- 1:length(u)
Alist <- list()
Alist$exposure <- create_alist_element(data$exposure_binned)
model_data <- list(
A = Alist,
M = Alist %>% map("A") %>% map(ncol) %>% reduce(sum) - 1,
n = length(unique(data$ID)),
X = sparse.model.matrix(eta ~ -1 + poly(exposure,degree = POLYNOMIAL_DEGREE,raw = TRUE),data = data)
)
model_data$theta_logprior <- function(theta,prior_alpha = .5,prior_u = log(10)) {
lambda <- -log(prior_alpha)/prior_u
log(lambda/2) - lambda * exp(-theta/2) - theta/2
}
model_data$beta_logprec <- log(.5)
model_data$diffmat <- create_diff_matrix(model_data$n)
model_data$lambdainv <- create_full_dtcp_matrix(model_data$n)
model_data$Xd <- model_data$diffmat %*% model_data$X
model_data$p <- ncol(model_data$X)
model_data$Nd <- model_data$n - 1
model_data$Ne <- model_data$n
model_data$Wd <- model_data$M + model_data$p + model_data$Nd
model_data$Wdf <- model_data$M + model_data$p + model_data$Ne
model_data$times <- data$times
model_data$censoring <- data$censoring
model_data$entry <- data$entry
model_data$ID <- data$ID
model_data$diffmat <- create_diff_matrix(model_data$n)
model_data$lambdainv <- create_full_dtcp_matrix(model_data$n)
model_data$A$exposure$Ad <- model_data$diffmat %*% model_data$A$exposure$A
model_data$Xd <- model_data$diffmat %*% model_data$X
thetagrid <- as.list(seq(4,12,by = 2)) # This is the log(precision)
# Random effect model specification data
model_data$modelspec <- model_data$A %>%
purrr::map("model") %>%
purrr::map2(.,names(.),~tibble(covariate = .y,model = .x)) %>%
purrr::reduce(bind_rows)
model_data$vectorofcolumnstoremove <- round(RW2BINS/2)
cat("Finished creating model data!\n")
control1 <- list(
prec = 1e-08,
stop.trust.radius = 1e-10,
report.freq = 10,
report.level = 4,
start.trust.radius = 100,
contract.threshold = .25,
contract.factor = .5,
expand.factor = 3,
trust.iter = 2000,
maxit = 3000,
preconditioner = 0
)
tm <- proc.time()
sim1opt <- optimize_all_thetas_parallel(
theta = thetagrid,
model_data = model_data,
startingvals = rep(0,model_data$Wd),
optcontrol = control1,
doparallel = PARALLEL_EXECUTION
)
rt <- proc.time() - tm
model_results <- add_log_posterior_values(sim1opt,model_data)
model_results
thetapostplot <- ggplot(mapping = aes(model_results$theta,model_results$theta_post)) + geom_line()
thetapostplot
model_results$theta_post <- exp(model_results$theta_logposterior)
thetapostplot <- ggplot(mapping = aes(model_results$theta,model_results$theta_post)) + geom_line()
thetapostplot
hessians <- model_results %>%
purrr::pmap(~list(
C = hessian_log_likelihood(W = ..4,model_data = model_data),
theta = ..1)
)
hessians
hessians[[1]]
myhess <- mclapply(X=model_results$solution,hessian_log_likelihood(,model_data = model_data))
myhess <- mclapply(X=model_results$solution,hessian_log_likelihood(~.x,model_data = model_data))
lapply(X=model_results$solution,hessian_log_likelihood(~.x,model_data = model_data))
model_results$solution
lapply(X=model_results$solution,hessian_log_likelihood(~.x,model_data = model_data))
lapply(X=model_results$solution,hessian_log_likelihood(~.x,model_data = model_data))
lapply(X=model_results$solution,hessian_log_likelihood())
lapply(X=model_results$solution,hessian_log_likelihood(,model_data = model_data))
lapply(X=model_results$solution,hessian_log_likelihood(~,model_data = model_data))
lapply(X=model_results$solution,hessian_log_likelihood(~x,model_data = model_data))
lapply(X=model_results$solution,hessian_log_likelihood(~X,model_data = model_data))
"da" + 3
hessian_log_likelihood(model_results$solution[[1]],model_data)
lapply(model_results, function)
lapply(model_results$solution, hessian_log_likelihood(~X,model_data))
?lapply
lapply(model_results$solution, "hessian_log_likelihood"(~X,model_data))
model_results$solution
model_results$solution[[1]]
lapply(model_results$solution, *2)
lapply(model_results$solution, "*2")
lapply(model_results$solution, mean)
lapply(model_results$solution, list(mean,var)
)
lapply(model_results$solution, list(mean(~X),va(mean(~X)r))
lapply(model_results$solution, list(mean(~X),va(mean(~X)))
)
lapply(model_results$solution, list(mean(~X),var(mean(~X)))
)
lapply(model_results$solution, mean(~.X))
lapply(model_results$solution, mean(~X))
lapply(model_results$solution, mean(~))
lapply(model_results$solution, mean(~))
lapply(model_results$solution, mean(~)
lapply(model_results$solution, mean(~
)
lapply(model_results$solution, hessian_log_likelihood(model_data))
lapply(model_results$solution, hessian_log_likelihood(model_data = model_data))
lapply(model_results$solution, hessian_log_likelihood
)
lapply(model_results$solution, hessian_log_likelihood)
lapply(model_results$solution, hessian_log_likelihood,model_data = model_data)
?mclapply
mclapply(model_results$solution, hessian_log_likelihood,model_data = model_data,mc.cores = 4)
myhes <- mclapply(model_results$solution, hessian_log_likelihood,model_data = model_data,mc.cores = 4)
myhes
myhes[[1]]
hessians[[1]]
hessians[[1]]$C - myhes[[1]]
myhess <- pmap(length(model_results$theta),list(
C = myhes[[.x]],
theta = model_results$theta[[.x]]))
myhess <- pmap(length(model_results$theta),list(
C = myhes[[~.x]],
theta = model_results$theta[[~.x]]))
myhess <- list()
for (i in 1:length(length(model_results$theta))) {
myhess[[i]] <- list(C=myhes[[i]],theta=model_results$theta[i])
}
myhess
myhess[[1]]
myhess[[1]]$C - hessians[[1]]$C
hessians[[1]]
myhess[[1]]
hessians
detectCores()
