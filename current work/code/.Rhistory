# P(sigma > u) = alpha.
# See inla.doc("pc.prec")
lambda <- -log(prior_alpha)/prior_u
log(lambda/2) - lambda * exp(-theta/2) - theta/2
}
# log(precision) for prior on beta
model_data$beta_logprec <- log(.05)
model_data$diffmat <- create_diff_matrix(model_data$n)
model_data$lambdainv <- create_full_dtcp_matrix(model_data$n)
model_data$Xd <- model_data$diffmat %*% model_data$X
tibble(x = c(-15,15)) %>%
ggplot(aes(x = x)) +
theme_light() +
stat_function(fun = function(x) exp(model_data$theta_logprior(x)))
model_data$p <- ncol(model_data$X)
model_data$Ne <- model_data$Nd + model_data$n
model_data$Wd <- model_data$M + model_data$p + model_data$Nd
model_data$Wdf <- model_data$M + model_data$p + model_data$Ne
model_data$times <- simdata$data$y
model_data$censoring <- data$censoring
model_data$entry <- data$entry
model_data$ID <- data$ID
#
#
#Let's check how long our "hessian_log_likelihood" function is gonna work for this sample size:
system.time(hessian_log_likelihood(W=rnorm(N),model_data))
#
#No theta in this model:
thetagrid <- list(0) # This is the log(precision)
#
#
#
#OPTIMAZTION:
PARALLEL_EXECUTION <- TRUE
control1 <- list(
prec = 1e-06,
stop.trust.radius = 1e-03,
report.freq = 1,
report.level = 4,
start.trust.radius = 100,
contract.threshold = .25,
contract.factor = .1,
expand.factor = 5,
preconditioner = 1,
trust.iter = 2000000,
cg.tol = 1e-06,
maxit = 1000
)
#Use sim:
#Need to install package "coxed" first!
set.seed(300)
N = 200
library(coxed)
simdata <- sim.survdata(N=N, T=200, xvars=3, censor=.3, num.data.frames = 1)
#True Betas:
simdata$betas
#Coxph Estimates:
model <- coxph(Surv(y, failed) ~ X1+X2+X3, data=simdata$data)
model$coefficients
set.seed(100)
N = 200
library(coxed)
simdata <- sim.survdata(N=N, T=200, xvars=3, censor=.3, num.data.frames = 1)
simdata$betas
#Coxph Estimates:
model <- coxph(Surv(y, failed) ~ X1+X2+X3, data=simdata$data)
model$coefficients
#INLA Estimates:
formula <- inla.surv(y,failed) ~ X1+X2+X3
Inlaresult <- inla(formula = formula, control.compute = list(dic=TRUE),data = simdata$data, family = "coxph",
control.hazard = list(model="rw2",n.intervals = 20))
Inlaresult$summary.fixed
#Manually setting up model_data that our algorithm will use
data <- data_frame(x = simdata$xdata, ID = 1:N, censoring = ifelse(simdata$data$failed,1,0), times = simdata$data$y, entry = rep(0,length(simdata$data$y)))
true_etas <- simdata$xb
model_data <- list(n=N,A=NULL,M=0,p=1,Nd = N-1,X=as.matrix(simdata$xdata))
model_data$theta_logprior <- function(theta,prior_alpha = .75,prior_u = log(20)) {
# In this model, theta is the LOG PRECISION of the rw2 smoothing variance
# Implement the PC prior directly.
# P(sigma > u) = alpha.
# See inla.doc("pc.prec")
lambda <- -log(prior_alpha)/prior_u
log(lambda/2) - lambda * exp(-theta/2) - theta/2
}
# log(precision) for prior on beta
model_data$beta_logprec <- log(.05)
model_data$diffmat <- create_diff_matrix(model_data$n)
model_data$lambdainv <- create_full_dtcp_matrix(model_data$n)
model_data$Xd <- model_data$diffmat %*% model_data$X
tibble(x = c(-15,15)) %>%
ggplot(aes(x = x)) +
theme_light() +
stat_function(fun = function(x) exp(model_data$theta_logprior(x)))
model_data$p <- ncol(model_data$X)
model_data$Ne <- model_data$Nd + model_data$n
model_data$Wd <- model_data$M + model_data$p + model_data$Nd
model_data$Wdf <- model_data$M + model_data$p + model_data$Ne
model_data$times <- simdata$data$y
model_data$censoring <- data$censoring
model_data$entry <- data$entry
model_data$ID <- data$ID
#
#
system.time(hessian_log_likelihood(W=rnorm(N),model_data))
thetagrid <- list(0) # This is the log(precision)
#OPTIMAZTION:
PARALLEL_EXECUTION <- TRUE
control1 <- list(
prec = 1e-06,
stop.trust.radius = 1e-03,
report.freq = 1,
report.level = 4,
start.trust.radius = 100,
contract.threshold = .25,
contract.factor = .1,
expand.factor = 5,
preconditioner = 1,
trust.iter = 2000000,
cg.tol = 1e-06,
maxit = 1000
)
tm <- proc.time()
sim1opt <- optimize_all_thetas_parallel(
theta = thetagrid,
# theta = -6,
model_data = model_data,
startingvals = rep(0,model_data$Wd),
optcontrol = control1,
doparallel = PARALLEL_EXECUTION
)
rt <- proc.time() - tm
compute_marginal_means(N,sim1opt,model_data)
compute_marginal_means(c(N,N+1,N+2),sim1opt,model_data)
compute_marginal_variances <- function(i,model_results,model_data,constrA = NULL,correction = -Inf) {
# W: vector of values of W to compute log pi(W_i|y) at
# i: index. which element of the latent field do you want the marginal for?
# model_results: tibble containing output of optimization
# Add log posterior values for theta if not present
if (!("theta_logposterior" %in% names(model_results))) {
model_results <- add_log_posterior_values(model_results,model_data)
}
# Normalize
thetanormconst <- normalize_log_posterior(model_results$theta_logposterior,model_results$theta)
model_results$theta_logposterior <- model_results$theta_logposterior - thetanormconst
precision_matrices <- model_results %>%
purrr::pmap(~list(Q = Q_matrix(theta = ..1,model_data = model_data),
theta = ..1)
)
print(class(precision_matrices))
hessians <- model_results %>%
purrr::pmap(~list(
C = hessian_log_likelihood(W = ..4,model_data = model_data),
theta = ..1)
)
print(class(hessians))
# Marginal variances: add the precision and the hessian and get diagOfInv
margvar <- purrr::map2(precision_matrices,hessians,~.x[["Q"]] + .y[["C"]]) %>%
purrr::map(~diagOfInv(x = .x,constrA = constrA,i = i)) %>%
purrr::reduce(rbind)
if (nrow(model_results) == 1) return(margvar)
postvals <- exp(model_results$theta_logposterior)
sweep(margvar,1,postvals,"*") %>% apply(2,sum)
}
compute_marginal_variances(c(N,N+1,N+2),sim1opt,model_data)
?chol()
?Cholesky
chol(a <- matrix(c(1,2,3,4),ncol=2))
chol(a <- matrix(c(5,0,0,4),ncol=2))
chol(a <- matrix(c(5,0,0,4),ncol=2)) %*%matrix(c(5,0,0,4),ncol=2)
?mapply(function, ...)
library(purrr)
?map
?map
compute_marginal_variances <- function(i,model_results,model_data,constrA = NULL,correction = -Inf) {
# W: vector of values of W to compute log pi(W_i|y) at
# i: index. which element of the latent field do you want the marginal for?
# model_results: tibble containing output of optimization
# Add log posterior values for theta if not present
if (!("theta_logposterior" %in% names(model_results))) {
model_results <- add_log_posterior_values(model_results,model_data)
}
# Normalize
thetanormconst <- normalize_log_posterior(model_results$theta_logposterior,model_results$theta)
model_results$theta_logposterior <- model_results$theta_logposterior - thetanormconst
precision_matrices <- model_results %>%
purrr::pmap(~list(Q = Q_matrix(theta = ..1,model_data = model_data),
theta = ..1)
)
print(class(precision_matrices$Q))
hessians <- model_results %>%
purrr::pmap(~list(
C = hessian_log_likelihood(W = ..4,model_data = model_data),
theta = ..1)
)
print(class(hessians$C))
# Marginal variances: add the precision and the hessian and get diagOfInv
margvar <- purrr::map2(precision_matrices,hessians,~.x[["Q"]] + .y[["C"]]) %>%
purrr::map(~diagOfInv(x = .x,constrA = constrA,i = i)) %>%
purrr::reduce(rbind)
if (nrow(model_results) == 1) return(margvar)
postvals <- exp(model_results$theta_logposterior)
sweep(margvar,1,postvals,"*") %>% apply(2,sum)
}
compute_marginal_variances(c(N,N+1,N+2),sim1opt,model_data)
compute_marginal_variances <- function(i,model_results,model_data,constrA = NULL,correction = -Inf) {
# W: vector of values of W to compute log pi(W_i|y) at
# i: index. which element of the latent field do you want the marginal for?
# model_results: tibble containing output of optimization
# Add log posterior values for theta if not present
if (!("theta_logposterior" %in% names(model_results))) {
model_results <- add_log_posterior_values(model_results,model_data)
}
# Normalize
thetanormconst <- normalize_log_posterior(model_results$theta_logposterior,model_results$theta)
model_results$theta_logposterior <- model_results$theta_logposterior - thetanormconst
precision_matrices <- model_results %>%
purrr::pmap(~list(Q = Q_matrix(theta = ..1,model_data = model_data),
theta = ..1)
)
print(precision_matrices)
hessians <- model_results %>%
purrr::pmap(~list(
C = hessian_log_likelihood(W = ..4,model_data = model_data),
theta = ..1)
)
print(hessians)
# Marginal variances: add the precision and the hessian and get diagOfInv
margvar <- purrr::map2(precision_matrices,hessians,~.x[["Q"]] + .y[["C"]]) %>%
purrr::map(~diagOfInv(x = .x,constrA = constrA,i = i)) %>%
purrr::reduce(rbind)
if (nrow(model_results) == 1) return(margvar)
postvals <- exp(model_results$theta_logposterior)
sweep(margvar,1,postvals,"*") %>% apply(2,sum)
}
compute_marginal_variances(c(N,N+1,N+2),sim1opt,model_data)
compute_marginal_variances <- function(i,model_results,model_data,constrA = NULL,correction = -Inf) {
# W: vector of values of W to compute log pi(W_i|y) at
# i: index. which element of the latent field do you want the marginal for?
# model_results: tibble containing output of optimization
# Add log posterior values for theta if not present
if (!("theta_logposterior" %in% names(model_results))) {
model_results <- add_log_posterior_values(model_results,model_data)
}
# Normalize
thetanormconst <- normalize_log_posterior(model_results$theta_logposterior,model_results$theta)
model_results$theta_logposterior <- model_results$theta_logposterior - thetanormconst
precision_matrices <- model_results %>%
purrr::pmap(~list(Q = Q_matrix(theta = ..1,model_data = model_data),
theta = ..1)
)
print(precision_matrices[["Q"]])
hessians <- model_results %>%
purrr::pmap(~list(
C = hessian_log_likelihood(W = ..4,model_data = model_data),
theta = ..1)
)
print(hessians[["C"]])
# Marginal variances: add the precision and the hessian and get diagOfInv
margvar <- purrr::map2(precision_matrices,hessians,~.x[["Q"]] + .y[["C"]]) %>%
purrr::map(~diagOfInv(x = .x,constrA = constrA,i = i)) %>%
purrr::reduce(rbind)
if (nrow(model_results) == 1) return(margvar)
postvals <- exp(model_results$theta_logposterior)
sweep(margvar,1,postvals,"*") %>% apply(2,sum)
}
compute_marginal_variances(c(N,N+1,N+2),sim1opt,model_data)
a <- matrix(c(1,2,4,0),ncol=2)
a
a <- as(a,Class = "dsyMatrix")
a <- matrix(c(1,2,2,0),ncol=2)
a <- as(a,Class = "dsyMatrix")
a
a <- as(a,Class = "dsCMatrix")
a
compute_marginal_variances <- function(i,model_results,model_data,constrA = NULL,correction = -Inf) {
# W: vector of values of W to compute log pi(W_i|y) at
# i: index. which element of the latent field do you want the marginal for?
# model_results: tibble containing output of optimization
# Add log posterior values for theta if not present
if (!("theta_logposterior" %in% names(model_results))) {
model_results <- add_log_posterior_values(model_results,model_data)
}
# Normalize
thetanormconst <- normalize_log_posterior(model_results$theta_logposterior,model_results$theta)
model_results$theta_logposterior <- model_results$theta_logposterior - thetanormconst
precision_matrices <- model_results %>%
purrr::pmap(~list(Q = as(Q_matrix(theta = ..1,model_data = model_data),Class = "dsCMatrix"),
theta = ..1)
)
hessians <- model_results %>%
purrr::pmap(~list(
C = hessian_log_likelihood(W = ..4,model_data = model_data),
theta = ..1)
)
# Marginal variances: add the precision and the hessian and get diagOfInv
margvar <- purrr::map2(precision_matrices,hessians,~.x[["Q"]] + .y[["C"]]) %>%
purrr::map(~diagOfInv(x = .x,constrA = constrA,i = i)) %>%
purrr::reduce(rbind)
if (nrow(model_results) == 1) return(margvar)
postvals <- exp(model_results$theta_logposterior)
sweep(margvar,1,postvals,"*") %>% apply(2,sum)
}
#
compute_marginal_variances(c(N,N+1,N+2),sim1opt,model_data)
compute_marginal_variances <- function(i,model_results,model_data,constrA = NULL,correction = -Inf) {
# W: vector of values of W to compute log pi(W_i|y) at
# i: index. which element of the latent field do you want the marginal for?
# model_results: tibble containing output of optimization
# Add log posterior values for theta if not present
if (!("theta_logposterior" %in% names(model_results))) {
model_results <- add_log_posterior_values(model_results,model_data)
}
# Normalize
thetanormconst <- normalize_log_posterior(model_results$theta_logposterior,model_results$theta)
model_results$theta_logposterior <- model_results$theta_logposterior - thetanormconst
precision_matrices <- model_results %>%
purrr::pmap(~list(Q = as(Q_matrix(theta = ..1,model_data = model_data),Class = "dsCMatrix"),
theta = ..1)
)
print(precision_matrices)
hessians <- model_results %>%
purrr::pmap(~list(
C = hessian_log_likelihood(W = ..4,model_data = model_data),
theta = ..1)
)
# Marginal variances: add the precision and the hessian and get diagOfInv
margvar <- purrr::map2(precision_matrices,hessians,~.x[["Q"]] + .y[["C"]]) %>%
purrr::map(~diagOfInv(x = .x,constrA = constrA,i = i)) %>%
purrr::reduce(rbind)
if (nrow(model_results) == 1) return(margvar)
postvals <- exp(model_results$theta_logposterior)
sweep(margvar,1,postvals,"*") %>% apply(2,sum)
}
compute_marginal_variances(c(N,N+1,N+2),sim1opt,model_data)
compute_marginal_variances <- function(i,model_results,model_data,constrA = NULL,correction = -Inf) {
# W: vector of values of W to compute log pi(W_i|y) at
# i: index. which element of the latent field do you want the marginal for?
# model_results: tibble containing output of optimization
# Add log posterior values for theta if not present
if (!("theta_logposterior" %in% names(model_results))) {
model_results <- add_log_posterior_values(model_results,model_data)
}
# Normalize
thetanormconst <- normalize_log_posterior(model_results$theta_logposterior,model_results$theta)
model_results$theta_logposterior <- model_results$theta_logposterior - thetanormconst
precision_matrices <- model_results %>%
purrr::pmap(~list(Q = as(Q_matrix(theta = ..1,model_data = model_data),Class = "dsCMatrix"),
theta = ..1)
)
hessians <- model_results %>%
purrr::pmap(~list(
C = hessian_log_likelihood(W = ..4,model_data = model_data),
theta = ..1)
)
print(hessians)
# Marginal variances: add the precision and the hessian and get diagOfInv
margvar <- purrr::map2(precision_matrices,hessians,~.x[["Q"]] + .y[["C"]]) %>%
purrr::map(~diagOfInv(x = .x,constrA = constrA,i = i)) %>%
purrr::reduce(rbind)
if (nrow(model_results) == 1) return(margvar)
postvals <- exp(model_results$theta_logposterior)
sweep(margvar,1,postvals,"*") %>% apply(2,sum)
}
compute_marginal_variances(c(N,N+1,N+2),sim1opt,model_data)
?sweep
compute_marginal_variances <- function(i,model_results,model_data,constrA = NULL,correction = -Inf) {
# W: vector of values of W to compute log pi(W_i|y) at
# i: index. which element of the latent field do you want the marginal for?
# model_results: tibble containing output of optimization
# Add log posterior values for theta if not present
if (!("theta_logposterior" %in% names(model_results))) {
model_results <- add_log_posterior_values(model_results,model_data)
}
# Normalize
thetanormconst <- normalize_log_posterior(model_results$theta_logposterior,model_results$theta)
model_results$theta_logposterior <- model_results$theta_logposterior - thetanormconst
precision_matrices <- model_results %>%
purrr::pmap(~list(Q = as(Q_matrix(theta = ..1,model_data = model_data),Class = "dsCMatrix"),
theta = ..1)
)
print(precision_matrices[[1]])
hessians <- model_results %>%
purrr::pmap(~list(
C = hessian_log_likelihood(W = ..4,model_data = model_data),
theta = ..1)
)
print(hessians[[1]])
# Marginal variances: add the precision and the hessian and get diagOfInv
margvar <- purrr::map2(precision_matrices,hessians,~.x[["Q"]] + .y[["C"]]) %>%
purrr::map(~diagOfInv(x = .x,constrA = constrA,i = i)) %>%
purrr::reduce(rbind)
if (nrow(model_results) == 1) return(margvar)
postvals <- exp(model_results$theta_logposterior)
sweep(margvar,1,postvals,"*") %>% apply(2,sum)
}
compute_marginal_variances(c(N,N+1,N+2),sim1opt,model_data)
compute_marginal_variances <- function(i,model_results,model_data,constrA = NULL,correction = -Inf) {
# W: vector of values of W to compute log pi(W_i|y) at
# i: index. which element of the latent field do you want the marginal for?
# model_results: tibble containing output of optimization
# Add log posterior values for theta if not present
if (!("theta_logposterior" %in% names(model_results))) {
model_results <- add_log_posterior_values(model_results,model_data)
}
# Normalize
thetanormconst <- normalize_log_posterior(model_results$theta_logposterior,model_results$theta)
model_results$theta_logposterior <- model_results$theta_logposterior - thetanormconst
precision_matrices <- model_results %>%
purrr::pmap(~list(Q = as(Q_matrix(theta = ..1,model_data = model_data),Class = "dsCMatrix"),
theta = ..1)
)
print(precision_matrices[[1]]$Q)
hessians <- model_results %>%
purrr::pmap(~list(
C = hessian_log_likelihood(W = ..4,model_data = model_data),
theta = ..1)
)
print(hessians[[1]]$C)
# Marginal variances: add the precision and the hessian and get diagOfInv
margvar <- purrr::map2(precision_matrices,hessians,~.x[["Q"]] + .y[["C"]]) %>%
purrr::map(~diagOfInv(x = .x,constrA = constrA,i = i)) %>%
purrr::reduce(rbind)
if (nrow(model_results) == 1) return(margvar)
postvals <- exp(model_results$theta_logposterior)
sweep(margvar,1,postvals,"*") %>% apply(2,sum)
}
#
#Variance of Beta:
compute_marginal_variances(c(N,N+1,N+2),sim1opt,model_data)
a
diag(a)
diag(diag(a))
compute_marginal_variances <- function(i,model_results,model_data,constrA = NULL,correction = -Inf) {
# W: vector of values of W to compute log pi(W_i|y) at
# i: index. which element of the latent field do you want the marginal for?
# model_results: tibble containing output of optimization
# Add log posterior values for theta if not present
if (!("theta_logposterior" %in% names(model_results))) {
model_results <- add_log_posterior_values(model_results,model_data)
}
# Normalize
thetanormconst <- normalize_log_posterior(model_results$theta_logposterior,model_results$theta)
model_results$theta_logposterior <- model_results$theta_logposterior - thetanormconst
precision_matrices <- model_results %>%
purrr::pmap(~list(Q = as(Q_matrix(theta = ..1,model_data = model_data),Class = "dsCMatrix"),
theta = ..1)
)
Q <- precision_matrices[[1]]$Q
hessians <- model_results %>%
purrr::pmap(~list(
C = hessian_log_likelihood(W = ..4,model_data = model_data),
theta = ..1)
)
C <- hessians[[1]]$C
# Marginal variances: add the precision and the hessian and get diagOfInv
margvar <- diag(diag(solve(C+Q))[i])
if (nrow(model_results) == 1) return(margvar)
postvals <- exp(model_results$theta_logposterior)
sweep(margvar,1,postvals,"*") %>% apply(2,sum)
}
compute_marginal_variances(c(N,N+1,N+2),sim1opt,model_data)
compute_marginal_variances <- function(i,model_results,model_data,constrA = NULL,correction = -Inf) {
# W: vector of values of W to compute log pi(W_i|y) at
# i: index. which element of the latent field do you want the marginal for?
# model_results: tibble containing output of optimization
# Add log posterior values for theta if not present
if (!("theta_logposterior" %in% names(model_results))) {
model_results <- add_log_posterior_values(model_results,model_data)
}
# Normalize
thetanormconst <- normalize_log_posterior(model_results$theta_logposterior,model_results$theta)
model_results$theta_logposterior <- model_results$theta_logposterior - thetanormconst
precision_matrices <- model_results %>%
purrr::pmap(~list(Q = as(Q_matrix(theta = ..1,model_data = model_data),Class = "dsCMatrix"),
theta = ..1)
)
Q <- precision_matrices[[1]]$Q
hessians <- model_results %>%
purrr::pmap(~list(
C = hessian_log_likelihood(W = ..4,model_data = model_data),
theta = ..1)
)
C <- -hessians[[1]]$C
# Marginal variances: add the precision and the hessian and get diagOfInv
margvar <- diag(diag(solve(C+Q))[i])
if (nrow(model_results) == 1) return(margvar)
postvals <- exp(model_results$theta_logposterior)
sweep(margvar,1,postvals,"*") %>% apply(2,sum)
}
#
#Variance of Beta:
compute_marginal_variances(c(N,N+1,N+2),sim1opt,model_data)
exp(log(.05))^(-1)
a <- c(0.0340298,0.0292808,0.03231007)
dnorm(seq(-5,5,by=0.01),mean = 0.14378332, sd = sqrt(0.0292808))
plot(dnorm(seq(-5,5,by=0.01),mean = 0.14378332, sd = sqrt(0.0292808)),type="l")
plot(dnorm(seq(-2,2,by=0.001),mean = 0.14378332, sd = sqrt(0.0292808)),type="l")
plot(dnorm(seq(-2,2,by=0.001),mean = 0.14378332, sd = sqrt(0.0292808)),type="l",xlab=seq(-2,2,by=0.001))
plot(dnorm(seq(-2,2,by=0.001),mean = 0.14378332, sd = sqrt(0.0292808)),type="l",xlim=seq(-2,2,by=0.001))
plot(dnorm(seq(-2,2,by=0.001),mean = 0.14378332, sd = sqrt(0.0292808)),type="l",xlim=2)
plot(dnorm(seq(-2,2,by=0.001),mean = 0.14378332, sd = sqrt(0.0292808)),type="l",xlim=c(-2,2))
plot(density = dnorm(seq(-2,2,by=0.001),mean = 0.14378332, sd = sqrt(0.0292808)),type="l",x = seq(-2,2,by=0.001) )
plot(dnorm(seq(-2,2,by=0.001),mean = 0.14378332, sd = sqrt(0.0292808))~x = seq(-2,2,by=0.001),type="l")
plot(dnorm(seq(-2,2,by=0.001),mean = 0.14378332, sd = sqrt(0.0292808))~seq(-2,2,by=0.001),type="l")
Inlaresult$marginals.hyperpar
Inlaresult$summary.fixed
0.1847337^2
0.0292808^2
0.1708872^2
0.1795343^2
lines(dnorm(seq(-2,2,by=0.001),mean = 0.15130911, sd =0.1708872)~seq(-2,2,by=0.001),type="l",col="r")
lines(dnorm(seq(-2,2,by=0.001),mean = 0.15130911, sd =0.1708872)~seq(-2,2,by=0.001),type="l",col="red")
